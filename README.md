Download Link: https://assignmentchef.com/product/solved-solved-chapter-15-linked-data-structures-java
<br>
What output is produced by the following code?LinkedList1 list = new LinkedList1();……………………………… Exercise 2: Define a boolean valued method named is Empty that can be added to the class linkedList1. The method returns true if the list is empty and false if the list has at least one node in it. Exercise 3: Define a void method named clear that can be added to the class LinkedList1. This method has no parameters and it empties the list. Exercise 4: Would it make any difference if we change the Node inner class from a private inner class to a public inner class? Exercise 5: Keeping the inner class Node as private, what differnce would it make if any of the instance variables or methods in the class Node had its access modifiers changed from private to public or package access? Exercise 6: Why does the definition of the inner class Node not have the accessor and mutator methods getLink, setLink, or other get and set methods for the link fields similar to those in the class definition of Node1 in the first display(when the class Node was separately defined.) Exercise 7: Would it be legal to add the following method to the class LinkedList2 (in Display 15.7)? Exercise 8: Rewrite the definition of the class LinkedList2 in Display 15.7 so that it has data of a type named Entry, which is a public inner class. Objects of type Entry have two instance variables defined as follows: Exercise 9 In the definition of copyOf in Diplsay 15.14, can we replace newHead = new Node((T)(position.data).clone(), null); with the following, which uses the copy constructor of T instead of the clone method of T? newHead = new Node(new T(position.data), null); Exercise 10: The definition of the clone method in Display 15.14 returns a vallue of type LinkedList. But the class being defined implements the PubliclyCloneable interface, and that interface says the value returned must be of type Object. Is something wrong? Exercise 11: Consider a variant of the class in Display 15.17 with no previous local variable. In other words, there is no reference kept to the node that links to the current node position. How could we modify the delete method to delete the position node and still maintain a correct list? The solution is less efficient than the version that uses previous. Exercise 12: a variant of the class in Display 15.17 with no previous local variable. In other words, there is no reference kept to the node that links to the current node position. Write a method addAfterHere(String newData) that adds a new node after the node in position. Exercise 13: Complete the definition of the method changeHere() in the inner class List2Iterator in Display 15.17. Exercise 14: Given an iterator pointing somewhere in a linked list, does i.next() return the value that i is referencing prior to the invocation of i.next() or does it return the value of the next node in the list?